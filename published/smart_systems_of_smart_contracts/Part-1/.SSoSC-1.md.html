<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Strict//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>/home/androlo/go/src/github.com/eris-ltd/solidity-resources/published/smart_systems_of_smart_contracts/Part-1/.SSoSC-1.md.html</title>


<style type="text/css">
body {
	color: #333;
	font: 13px/1.4 "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif;
	padding: 0;
	margin: 0;
}

a {
	background: transparent;
	color: #4183c4;
	text-decoration: none;
}

a:active,
a:hover {
	outline: 0 none;
	text-decoration: underline;
}

abbr[title] {
	border-bottom: 1px dotted;
}

b,
strong {
	font-weight: bold;
}

dfn {
	font-style: italic;
}
h1 {
	font-size: 2em;
	margin: 0.67em 0;
}
mark {
	background: #ff0;
	color: #000;
}
small {
	font-size: 80%;
}
sub, sup {
	font-size: 75%;
	line-height: 0;
	position: relative;
	vertical-align: baseline;
}
sup {
	top: -0.5em;
}
sub {
	bottom: -0.25em;
}
img {
	border: 0 none;
}
svg:not(:root) {
	overflow: hidden;
}
figure {
	margin: 1em 40px;
}
hr {
	box-sizing: content-box;
	height: 0;
}

code,
kbd,
pre,
samp {
	font-family: monospace,monospace;
	font-size: 1em;
}

pre {
	overflow: auto;
	font: 12px Consolas,"Liberation Mono",Menlo,Courier,monospace;
	margin-bottom: 0;
	margin-top: 0;
}

.markdown-body {
	padding: 30px;
	font-size: 16px;
	line-height: 1.6;
	word-wrap: break-word;
}

.markdown-body>*:first-child {
	margin-top: 0 !important;
}

.markdown-body>*:last-child {
	margin-bottom: 0 !important;
}

.markdown-body .absent {
	color: #c00;
}

.markdown-body .anchor {
	position: absolute;
	top: 0;
	bottom: 0;
	left: 0;
	display: block;
	padding-right: 6px;
	padding-left: 30px;
	margin-left: -30px;
}

.markdown-body .anchor:focus {
	outline: none;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
	position: relative;
	margin-top: 1em;
	margin-bottom: 16px;
	font-weight: bold;
	line-height: 1.4;
}

.markdown-body h1 .octicon-link,
.markdown-body h2 .octicon-link,
.markdown-body h3 .octicon-link,
.markdown-body h4 .octicon-link,
.markdown-body h5 .octicon-link,
.markdown-body h6 .octicon-link {
	display: none;
	color: #000;
	vertical-align: middle;
}

.markdown-body h1:hover .anchor,
.markdown-body h2:hover .anchor,
.markdown-body h3:hover .anchor,
.markdown-body h4:hover .anchor,
.markdown-body h5:hover .anchor,
.markdown-body h6:hover .anchor {
	padding-left: 8px;
	margin-left: -30px;
	line-height: 1;
	text-decoration: none;
}

.markdown-body h1:hover .anchor .octicon-link,
.markdown-body h2:hover .anchor .octicon-link,
.markdown-body h3:hover .anchor .octicon-link,
.markdown-body h4:hover .anchor .octicon-link,
.markdown-body h5:hover .anchor .octicon-link,
.markdown-body h6:hover .anchor .octicon-link {
	display: inline-block;
}

.markdown-body h1 tt,
.markdown-body h1 code,
.markdown-body h2 tt,
.markdown-body h2 code,
.markdown-body h3 tt,
.markdown-body h3 code,
.markdown-body h4 tt,
.markdown-body h4 code,
.markdown-body h5 tt,
.markdown-body h5 code,
.markdown-body h6 tt,
.markdown-body h6 code {
	font-size: inherit;
}

.markdown-body h1 {
	padding-bottom: 0.3em;
	font-size: 2.25em;
	line-height: 1.2;
	border-bottom: 1px solid #eee;
}

.markdown-body h2 {
	padding-bottom: 0.3em;
	font-size: 1.75em;
	line-height: 1.225;
	border-bottom: 1px solid #eee;
}

.markdown-body h3 {
	font-size: 1.5em;
	line-height: 1.43;
}

.markdown-body h4 {
	font-size: 1.25em;
}

.markdown-body h5 {
	font-size: 1em;
}

.markdown-body h6 {
	font-size: 1em;
	color: #777;
}

.markdown-body p,.markdown-body blockquote,
.markdown-body ul,.markdown-body ol,
.markdown-body dl,.markdown-body table,
.markdown-body pre {
	margin-top: 0;
	margin-bottom: 16px;
}

.markdown-body hr {
	height: 4px;
	padding: 0;
	margin: 16px 0;
	background-color: #e7e7e7;
	border: 0 none;
}

.markdown-body ul,
.markdown-body ol {
	padding-left: 2em;
}

.markdown-body ul.no-list,
.markdown-body ol.no-list {
	padding: 0;
	list-style-type: none;
}

.markdown-body ul ul,
.markdown-body ul ol,
.markdown-body ol ol,
.markdown-body ol ul {
	margin-top: 0;
	margin-bottom: 0;
}

.markdown-body li>p {
	margin-top: 16px;
}

.markdown-body dl {
	padding: 0;
}

.markdown-body dl dt {
	padding: 0;
	margin-top: 16px;
	font-size: 1em;
	font-style: italic;
	font-weight: bold;
}

.markdown-body dl dd {
	padding: 0 16px;
	margin-bottom: 16px;
}

.markdown-body blockquote {
	padding: 0 15px;
	color: #777;
	border-left: 4px solid #ddd;
}

.markdown-body blockquote>:first-child {
	margin-top: 0;
}

.markdown-body blockquote>:last-child {
	margin-bottom: 0;
}

.markdown-body table {
	display: block;
	width: 100%;
	overflow: auto;
	word-break: normal;
	word-break: keep-all;
}

.markdown-body table th {
	font-weight: bold;
}

.markdown-body table th,
.markdown-body table td {
	padding: 6px 13px;
	border: 1px solid #ddd;
}

.markdown-body table tr {
	background-color: #fff;
	border-top: 1px solid #ccc;
}

.markdown-body table tr:nth-child(2n) {
	background-color: #f8f8f8;
}

.markdown-body img {
	max-width: 100%;
	-moz-box-sizing: border-box;
	box-sizing: border-box;
}

.markdown-body span.frame {
	display: block;
	overflow: hidden;
}

.markdown-body span.frame>span {
	display: block;
	float: left;
	width: auto;
	padding: 7px;
	margin: 13px 0 0;
	overflow: hidden;
	border: 1px solid #ddd;
}

.markdown-body span.frame span img {
	display: block;
	float: left;
}

.markdown-body span.frame span span {
	display: block;
	padding: 5px 0 0;
	clear: both;
	color: #333;
}

.markdown-body span.align-center {
	display: block;
	overflow: hidden;
	clear: both;
}

.markdown-body span.align-center>span {
	display: block;
	margin: 13px auto 0;
	overflow: hidden;
	text-align: center;
}

.markdown-body span.align-center span img {
	margin: 0 auto;
	text-align: center;
}

.markdown-body span.align-right {
	display: block;
	overflow: hidden;
	clear: both;
}

.markdown-body span.align-right>span {
	display: block;
	margin: 13px 0 0;
	overflow: hidden;
	text-align: right;
}

.markdown-body span.align-right span img {
	margin: 0;
	text-align: right;
}

.markdown-body span.float-left {
	display: block;
	float: left;
	margin-right: 13px;
	overflow: hidden;
}

.markdown-body span.float-left span {
	margin: 13px 0 0;
}

.markdown-body span.float-right {
	display: block;
	float: right;
	margin-left: 13px;
	overflow: hidden;
}

.markdown-body span.float-right>span {
	display: block;
	margin: 13px auto 0;
	overflow: hidden;
	text-align: right;
}

.markdown-body code,.markdown-body tt {
	padding: 0;
	padding-top: 0.2em;
	padding-bottom: 0.2em;
	margin: 0;
	font-size: 85%;
	background-color: rgba(0,0,0,0.04);
	border-radius: 3px;
}

.markdown-body code:before,
.markdown-body code:after,
.markdown-body tt:before,
.markdown-body tt:after {
	letter-spacing: -0.2em;
	content: "\00a0";
}

.markdown-body code br,
.markdown-body tt br {
	display: none;
}

.markdown-body del code {
	text-decoration: inherit;
}

.markdown-body pre>code {
	padding: 0;
	margin: 0;
	font-size: 100%;
	word-break: normal;
	white-space: pre;
	background: transparent;
	border: 0;
}

.markdown-body .highlight {
	margin-bottom: 16px;
}

.markdown-body .highlight pre,
.markdown-body pre {
	padding: 16px;
	overflow: auto;
	font-size: 85%;
	line-height: 1.45;
	background-color: #f7f7f7;
	border-radius: 3px;
}

.markdown-body .highlight pre {
	margin-bottom: 0;
	word-break: normal;
}

.markdown-body pre {
	word-wrap: normal;
}

.markdown-body pre code,
.markdown-body pre tt {
	display: inline;
	max-width: initial;
	padding: 0;
	margin: 0;
	overflow: initial;
	line-height: inherit;
	word-wrap: normal;
	background-color: transparent;
	border: 0;
}

.markdown-body pre code:before,
.markdown-body pre code:after,
.markdown-body pre tt:before,
.markdown-body pre tt:after {
	content: normal;
}

.highlight .pl-coc,
.highlight .pl-entl,
.highlight .pl-entm,
.highlight .pl-eoa,
.highlight .pl-mai .pl-sf,
.highlight .pl-mm,
.highlight .pl-pdv,
.highlight .pl-sc,
.highlight .pl-som,
.highlight .pl-sr,
.highlight .pl-v,
.highlight .pl-vpf {
	color: #0086b3;
}
.highlight .pl-eoac,
.highlight .pl-mdht,
.highlight .pl-mi1,
.highlight .pl-mri,
.highlight .pl-va,
.highlight .pl-vpu {
	color: #008080;
}
.highlight .pl-c,
.highlight .pl-pdc {
	color: #b4b7b4;
	font-style: italic;
}
.highlight .pl-k,
.highlight .pl-ko,
.highlight .pl-kolp,
.highlight .pl-mc,
.highlight .pl-mr,
.highlight .pl-ms,
.highlight .pl-s,
.highlight .pl-sok,
.highlight .pl-st {
	color: #6e5494;
}
.highlight .pl-ef,
.highlight .pl-enf,
.highlight .pl-enm,
.highlight .pl-entc,
.highlight .pl-eoi,
.highlight .pl-sf,
.highlight .pl-smc {
	color: #d12089;
}
.highlight .pl-ens,
.highlight .pl-eoai,
.highlight .pl-kos,
.highlight .pl-mh .pl-pdh,
.highlight .pl-mp,
.highlight .pl-pde,
.highlight .pl-stp {
	color: #458;
}
.highlight .pl-enti {
	color: #d12089;
	font-weight: bold;
}
.highlight .pl-cce,
.highlight .pl-enc,
.highlight .pl-kou,
.highlight .pl-mq {
	color: #f93;
}
.highlight .pl-mp1 .pl-sf {
	color: #458;
	font-weight: bold;
}
.highlight .pl-cos,
.highlight .pl-ent,
.highlight .pl-md,
.highlight .pl-mdhf,
.highlight .pl-ml,
.highlight .pl-pdc1,
.highlight .pl-pds,
.highlight .pl-s1,
.highlight .pl-scp,
.highlight .pl-sol {
	color: #df5000;
}
.highlight .pl-c1,
.highlight .pl-cn,
.highlight .pl-pse,
.highlight .pl-pse .pl-s2,
.highlight .pl-vi {
	color: #a31515;
}
.highlight .pl-mb,
.highlight .pl-pdb {
	color: #df5000;
	font-weight: bold;
}
.highlight .pl-mi,
.highlight .pl-pdi {
	color: #6e5494;
	font-style: italic;
}
.highlight .pl-ms1 {
	background-color: #f5f5f5;
}
.highlight .pl-mdh,
.highlight .pl-mdi {
	font-weight: bold;
}
.highlight .pl-mdr {
	color: #0086b3;
	font-weight: bold;
}
.highlight .pl-s2 {
	color: #333;
}
.highlight .pl-ii {
	background-color: #df5000;
	color: #fff;
}
.highlight .pl-ib {
	background-color: #f93;
}
.highlight .pl-id {
	background-color: #a31515;
	color: #fff;
}
.highlight .pl-iu {
	background-color: #b4b7b4;
}
.highlight .pl-mo {
	color: #969896;
}

</style>


<script type="text/javascript">

function getDocumentScrollTop() 
{
   var res = document.body.scrollTop || document.documentElement.scrollTop || window.pageYOffset || 0;
   // alert(res);
   return res;
}

function setDocumentScrollTop(ypos) 
{
	window.scrollTo(0, ypos);
}

</script>


</head>
<body class="markdown-body">
<h2> <a id="user-content-smart-systems-of-smart-contracts" class="anchor" href="#smart-systems-of-smart-contracts" aria-hidden="true"><span class="octicon octicon-link"></span></a>Smart systems of smart contracts</h2> 
<p><strong>Part 1: The five type model</strong></p> 
<p><em>By: Andreas Olofsson (<a href="mailto:andreas@erisindustries.com">andreas@erisindustries.com</a>)</em></p> 
<p>(Note: When writing this - Feb 2nd, 2015 - Solidity is still under heavy development, which means running the actual code is hard, and since it's on dev it cannot be assumed to be stable). I still chose Solidity as that is becoming the next big language, and it is clean enough to make for good &quot;pseudo code&quot; as well.</p> 
<h3> <a id="user-content-introduction" class="anchor" href="#introduction" aria-hidden="true"><span class="octicon octicon-link"></span></a>Introduction</h3> 
<p>This is an introduction to systems of smart contracts. The purpose of these documents is to teach methods of writing large, scalable smart contract back-ends for distributed applications. The reader should be familiar with the basics of smart contract writing, and they should know what accounts, contracts and transactions are, and how to work with them. A good introduction to Ethereum development (and a must-read) can be found <a href="https://github.com/ethereum/wiki/wiki/Ethereum-Development-Tutorial">here</a>. </p> 
<p>The example code in this document is written in the new Solidity language. The official tutorial can be found <a href="https://github.com/ethereum/wiki/wiki/Solidity-Tutorial">here</a>. This language is not production ready, but most of the basic features are in place and contracts can be compiled and run in live systems. If you want to start developing with Solidity, which I recommend, you should check out the <a href="https://github.com/ethereum/wiki/wiki/Solidity-Features">features document</a>. It is being updated continuously, and shows when new features are added, and is less technical the the information found in the <a href="https://www.pivotaltracker.com/n/projects/1189488">pivotal tracker</a>.</p> 
<p>On top of this, I would also recommend checking out the <a href="https://github.com/ethereum/wiki/wiki">Ethereum wiki</a>. It has links to the above mentioned docs, and a lot of other information as well, such as the contract ABI, the natspec (for documentation), the Ethereum white and yellow papers, etc. There's a also a number of community sites; most importantly the <a href="https://forum.ethereum.org/">Ethereum forums</a> and <a href="http://www.reddit.com/r/ethereum">subreddit</a>.</p> 
<p>About trust: The systems we study here are designed to be modular, ie parts of the code can be replaced during runtime, which in turn makes them inherently trust-ful. Someone must be allowed to make these updates. It is important to know this. If you want to learn how to write small trust-less, automated systems this is not really the place (although many of the principles are the same in both types of systems). </p> 
<p><strong>Smart contracts as services</strong></p> 
<p>One way of thinking about smart contracts, and the way we're going to think about them here, is as extremely basic, state-less web-services. Webservices are units of functionality in a system (the internet), with a well defined API and an identifier (IP address) that can be used to call them. Similarly, a smart contract is a unit of functionality in the Ethereum system, the functions exposed by their Solidity contracts would be the (rpc) API, and their public address is the identifier. A web-service is normally called by making an http request, and a contract is called by making a transaction. Also, in most cases everyone is allowed to call them - the endpoints are exposed to the public, so security must be handled on a call-by-call basis, and the same thing goes for contracts and their functions. We can even utilize patterns and architectures, such as for example the <a href="http://martinfowler.com/articles/microservices.html">microservices architecture</a>.</p> 
<p>Finally, before we get started it is important to know this: Writing smart contracts can be tricky. The transition from normal code writing to smart contract writing is not seamless. The environment in which smart contract code runs is different from that of normal code. The analogy with webservices is good, because it makes smart contracts and systems of smart contracts more tangible, and it makes it simpler to use already existing concepts and tools when working with them, but writing the actual code is still difficult. The biggest issue at this point is not really the languages, or VM layout, but the fact that that neither Ethereum or Solidity is production ready so on top of learning how to write the normal code we also have to worry about bugs, changes, and implementing low level functionality that has not yet become language (or Ethereum) features.</p> 
<h4> <a id="user-content-a-simple-smart-contract" class="anchor" href="#a-simple-smart-contract" aria-hidden="true"><span class="octicon octicon-link"></span></a>A simple smart contract</h4> 
<p>This document is about systems of smart contracts, but we will start by looking at single contracts. This for example is a standard name registry contract. Name registry, or &quot;namereg&quot; contracts generally lets people associate a name with an Ethereum account address. This is an example of such a contract:</p> 
<div class="highlight highlight-javascript">
 <pre>contract Users {
    <span class="pl-c">// Here we store the names. Make it public to automatically generate an </span>
    <span class="pl-c">// accessor function named 'users' that takes a string as argument.</span>
    mapping (string32 <span class="pl-k">=&gt;</span> address) <span class="pl-s">public</span> users;

    <span class="pl-c">// Register the provided name with the caller address.</span>
    <span class="pl-c">// Also, we don't want them to register &quot;&quot; as their name.</span>
    <span class="pl-st">function</span> <span class="pl-en">register</span>(<span class="pl-vpf">string32</span> name) {
        <span class="pl-k">if</span>(users[name] <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> name <span class="pl-k">!=</span> <span class="pl-s1"><span class="pl-pds">&quot;</span><span class="pl-pds">&quot;</span></span>){
            users[name] <span class="pl-k">=</span> msg.sender;
        }
    }

    <span class="pl-c">// Unregister the provided name with the caller address.</span>
    <span class="pl-st">function</span> <span class="pl-en">unregister</span>(<span class="pl-vpf">string32</span> name) {
        <span class="pl-k">if</span>(users[name] <span class="pl-k">!=</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> name <span class="pl-k">!=</span> <span class="pl-s1"><span class="pl-pds">&quot;</span><span class="pl-pds">&quot;</span></span>){
            users[name] <span class="pl-k">=</span> <span class="pl-c1">0x0</span>;
        }
    }
}</pre>
</div> 
<p>When this contract is called, it will use <code>msg.sender</code> and a provided <code>name</code> as parameters. <code>msg.sender</code> refers to the address of the account that made the transaction. <code>name</code> is a string that the sender includes in the transaction data. If the name is not already taken, it will be written into users.</p> 
<p>This is a very basic but useful contract. It lets you refer to users by name instead of having to use their public address. It could be used as a basis for almost anything. It could use some more functionality, such as being able to list all the registered users, and maybe also make it possible to get a name by address, and not just address by name, and other things. We're not going to study namereg contracts here though, we're going to study systems, so we'll start with another contract instead:</p> 
<div class="highlight highlight-javascript">
 <pre>contract HelloSystem {
}</pre>
</div> 
<h4> <a id="user-content-deploying-and-removing-contracts" class="anchor" href="#deploying-and-removing-contracts" aria-hidden="true"><span class="octicon octicon-link"></span></a>Deploying and removing contracts</h4> 
<p>The <code>HelloSystem</code> contract can be deployed as-is without any problems, but once it's been deployed it will remain on the chain for good. We need a way to remove it. In Solidity, the command for removing (or suiciding) a contract is this: <code>suicide(addr)</code>. The argument here is the address to which any remaining funds should be sent. In order to expose this functionality, we need to put it inside a (implicitly public) function. This is what a suicide function could look like in <code>HelloSystem</code>:</p> 
<div class="highlight highlight-javascript">
 <pre>contract HelloSystem {

    <span class="pl-st">function</span> <span class="pl-en">remove</span>() {
        suicide(msg.sender);
    }
}</pre>
</div> 
<p>What this would do is to remove the contract when the <code>remove</code> function is called, and it would return any funds it may have to the caller. Needless to say, this is not ideal. Normally when you add a suicide function you want to restrict the access to it. The simplest way of doing it is to store the address of the contract creator when the contract is deployed, and only allow the creator to suicide it. Here is how that could be implemented:</p> 
<div class="highlight highlight-javascript">
 <pre>contract HelloSystem {

    address owner;

    <span class="pl-c">// Constructor</span>
    <span class="pl-st">function</span> <span class="pl-en">HelloSystem</span>(){
        owner <span class="pl-k">=</span> msg.sender;
    }

    <span class="pl-st">function</span> <span class="pl-en">remove</span>() {
        <span class="pl-k">if</span> (msg.sender <span class="pl-k">==</span> owner){
            suicide(owner);
        }
    }

}</pre>
</div> 
<p><em>Note that <code>msg.sender</code> is not the same in the constructor as it is in the remove function. The constructor is called when the contract is added, so <code>msg.sender</code> will be the contract creator, but in all other functions it will be the address of the account that is calling it.</em></p> 
<p>There are several different ways to control how contracts are added and removed. Users can create them by making a create-transaction to the client. Another way is to have contracts create them. Contracts are allowed to create other contracts. Here is one example of a contract that creates a <code>HelloSystem</code> contract.</p> 
<div class="highlight highlight-javascript">
 <pre>contract HelloSystem {

    address owner;

    <span class="pl-c">// Constructor</span>
    <span class="pl-st">function</span> <span class="pl-en">HelloSystem</span>(){
        owner <span class="pl-k">=</span> msg.sender;
    }

    <span class="pl-st">function</span> <span class="pl-en">remove</span>() {
        <span class="pl-k">if</span> (msg.sender <span class="pl-k">==</span> owner){
            suicide(owner);
        }
    }
}

contract HelloFactory {

    <span class="pl-st">function</span> <span class="pl-en">createHS</span>() returns (address hsAddr) {
        <span class="pl-k">return</span> address(<span class="pl-k">new</span> <span class="pl-en">HelloSystem</span>());
    }

    <span class="pl-st">function</span> <span class="pl-en">deleteHS</span>(<span class="pl-vpf">address</span> hs){
        HelloSystem(hs).<span class="pl-s3">remove</span>();
    }

}</pre>
</div> 
<p>Notice what happened here. We're creating a new contract but we aren't adding it to a mapping or other variable, instead we just create it and pass its address back to the caller. We need the <code>deleteHS</code> function because the creator of all the <code>HelloSystem</code> contracts is <code>HelloFactory</code>, which means that <code>HelloFactory</code> is the only contract (or account) that is allowed to remove them.</p> 
<h4> <a id="user-content-account-permissions-and-contract-dependencies" class="anchor" href="#account-permissions-and-contract-dependencies" aria-hidden="true"><span class="octicon octicon-link"></span></a>Account permissions and contract dependencies</h4> 
<p>When it comes to the relations between different parts of the system, there are two things we have to keep track of:</p> 
<p><strong>1) The dependencies in terms of code</strong></p> 
<p><strong>2) The dependencies in terms of permissions</strong></p> 
<p>If we look at <code>HelloFactory</code> we can see that <code>HelloSystem</code> is a dependency because <code>HelloFactory</code> is calling functions on that contract. <code>HelloSystem</code>, on the other hand, does not need to call any functions on <code>HelloFactory</code>. When it comes to permissions it is the other way around; <code>HelloFactory</code> will allow calls from any account whereas <code>HelloSystem</code> only accept calls that are made from one single account, namely that of its owner (which in this case is a <code>HelloFactory</code> contract account).</p> 
<p><a href="img/SSoSC1-1.png" target="_blank"><img src="img/SSoSC1-1.png" alt="SSoSC1-1" style="max-width:100%;" /></a></p> 
<p><a href="img/Legend.png" target="_blank"><img src="img/Legend.png" alt="Legend" style="max-width:100%;" /></a></p> 
<p>We need to use permissions like this because each contract is a separate account that can be called by any account in the system. Even when we include a contract in the source file of another contract as with <code>HelloFactory</code>, each new contract will still be created as a separate, new contract account that is unrelated to its factory except for any references we might add ourselves.</p> 
<p><a href="img/ContractsOnChain.png" target="_blank"><img src="img/ContractsOnChain.png" alt="ContractsOnChain" style="max-width:100%;" /></a></p> 
<h4> <a id="user-content-a-simple-banking-system" class="anchor" href="#a-simple-banking-system" aria-hidden="true"><span class="octicon octicon-link"></span></a>A simple banking system</h4> 
<p>We're now going to make a simple bank account contract that lets people deposit and withdraw money (Ether). We're going to start by putting all the blockchain logic in one single contract.</p> 
<div class="highlight highlight-javascript">
 <pre>contract Bank {

    <span class="pl-c">// We want an owner that is allowed to suicide.</span>
    address owner;

    mapping (address <span class="pl-k">=&gt;</span> uint) balances;

    <span class="pl-c">// Constructor</span>
    <span class="pl-st">function</span> <span class="pl-en">Bank</span>(){
        owner <span class="pl-k">=</span> msg.sender;
    }

    <span class="pl-c">// This will take the value of the transaction and add to the senders account.</span>
    <span class="pl-st">function</span> <span class="pl-en">deposit</span>() {
        balances[msg.sender] <span class="pl-k">+=</span> msg.<span class="pl-sc">value</span>;
    }

    <span class="pl-c">// Attempt to withdraw the given 'amount' of Ether from the account.</span>
    <span class="pl-st">function</span> <span class="pl-en">withdraw</span>(<span class="pl-vpf">uint</span> amount) {
        <span class="pl-c">// Skip if someone tries to withdraw 0 or if they don't have enough Ether to make the withdrawal.</span>
        <span class="pl-k">if</span> (balances[msg.sender] <span class="pl-k">&lt;</span> amount <span class="pl-k">||</span> amount <span class="pl-k">==</span> <span class="pl-c1">0</span>) 
            <span class="pl-k">return</span>;
        balances[msg.sender] <span class="pl-k">-=</span> amount;
        msg.sender.<span class="pl-s3">send</span>(amount);
    }

    <span class="pl-st">function</span> <span class="pl-en">remove</span>() {
        <span class="pl-k">if</span> (msg.sender <span class="pl-k">==</span> owner){
            suicide(owner);
        }
    }

}</pre>
</div> 
<p>This contract will let other accounts deposit and withdraw Ether, but it does not scale very well. Let's say we run a DApp that uses this contract. Eventually we may have a lot of users, and they would probably start requesting new features. Maybe they have other funds (like Ethereum-driven altcoins) and would like to keep everything under the same umbrella. We could just extend the UI to point to these other contracts as well, and manage everything like that, but everything would be disconnected. People would have to use multiple user names, multiple accounts, etc. At some point we would probably want to encapsulate some of the logic into contracts. Unfortunately, our users would still have to call the bank contract directly because it checks the caller address in both the <code>deposit</code> and <code>withdraw</code> functions, which means we can't really use a proxy account. Another problem is that the functions has no return values, so a contract that calls the bank can't really know if its calls succeeded or not.</p> 
<p>If we want the bank contract to be more suited for a system, we could change it into something like this:</p> 
<div class="highlight highlight-javascript">
 <pre>contract Bank {

    address owner;

    mapping (address <span class="pl-k">=&gt;</span> uint) balances;

    <span class="pl-c">// Constructor</span>
    <span class="pl-st">function</span> <span class="pl-en">Bank</span>(){
        owner <span class="pl-k">=</span> msg.sender;
    }

    <span class="pl-c">// This will take the value of the transaction and add to the senders account.</span>
    <span class="pl-st">function</span> <span class="pl-en">deposit</span>(<span class="pl-vpf">address</span> customer) constant returns (bool res) {
        <span class="pl-c">// If the amount they send is 0, return false.</span>
        <span class="pl-k">if</span> (msg.<span class="pl-sc">value</span> <span class="pl-k">==</span> <span class="pl-c1">0</span>){
            <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        }
        balances[customer] <span class="pl-k">+=</span> msg.<span class="pl-sc">value</span>;
        <span class="pl-k">return</span> <span class="pl-c1">true</span>;
    }

    <span class="pl-c">// Attempt to withdraw the given 'amount' of Ether from the account.</span>
    <span class="pl-st">function</span> <span class="pl-en">withdraw</span>(<span class="pl-vpf">address</span> customer, <span class="pl-vpf">uint</span> amount) constant returns (bool res) {
        <span class="pl-c">// Skip if someone tries to withdraw 0 or if they don't have </span>
        <span class="pl-c">// enough Ether to make the withdrawal.</span>
        <span class="pl-k">if</span> (balances[customer] <span class="pl-k">&lt;</span> amount <span class="pl-k">||</span> amount <span class="pl-k">==</span> <span class="pl-c1">0</span>) 
            <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        balances[customer] <span class="pl-k">-=</span> amount;
        msg.sender.<span class="pl-s3">send</span>(amount);
        <span class="pl-k">return</span> <span class="pl-c1">true</span>;
    }

    <span class="pl-st">function</span> <span class="pl-en">remove</span>() {
        <span class="pl-k">if</span> (msg.sender <span class="pl-k">==</span> owner){
            suicide(owner);
        }
    }

}</pre>
</div> 
<p>Now let us make a simple fund management contract that takes a bank contract address as a parameter. It also deploys the bank contract automatically and keeps track of it.</p> 
<div class="highlight highlight-javascript">
 <pre><span class="pl-c">// The bank contract</span>
contract Bank {
    <span class="pl-c">// All the logic from the bank contract.</span>
    ...
}

contract FundManager {

    <span class="pl-c">// We still want an owner.</span>
    address owner;
    <span class="pl-c">// This holds a reference to the current bank contract.</span>
    address bank;

    <span class="pl-c">// Constructor</span>
    <span class="pl-st">function</span> <span class="pl-en">FundManager</span>(){
        owner <span class="pl-k">=</span> msg.sender;
        bank <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Bank</span>();
    }

    <span class="pl-c">// Attempt to withdraw the given 'amount' of Ether from the account.</span>
    <span class="pl-st">function</span> <span class="pl-en">deposit</span>() constant returns (bool res) {
        <span class="pl-k">if</span> (msg.<span class="pl-sc">value</span> <span class="pl-k">==</span> <span class="pl-c1">0</span>){
            <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        }
        <span class="pl-k">if</span> ( bank <span class="pl-k">==</span> <span class="pl-c1">0x0</span> ) {
            <span class="pl-c">// If the user sent money, we should return it if we can't deposit.</span>
            msg.sender.<span class="pl-s3">send</span>(msg.<span class="pl-sc">value</span>);
            <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        }

        <span class="pl-c">// Use the interface to call on the bank contract. We pass msg.value along as well.</span>
        bool success <span class="pl-k">=</span> Bank(bank).deposit.<span class="pl-sc">value</span>(msg.<span class="pl-sc">value</span>)(msg.sender);

        <span class="pl-c">// If the transaction failed, return the Ether to the caller.</span>
        <span class="pl-k">if</span> (<span class="pl-k">!</span>success) {
            msg.sender.<span class="pl-s3">send</span>(msg.<span class="pl-sc">value</span>);
        }
        <span class="pl-k">return</span> success;
    }

    <span class="pl-c">// Attempt to withdraw the given 'amount' of Ether from the account.</span>
    <span class="pl-st">function</span> <span class="pl-en">withdraw</span>(<span class="pl-vpf">uint</span> amount) constant returns (bool res) {
        <span class="pl-k">if</span> ( bank <span class="pl-k">==</span> <span class="pl-c1">0x0</span> ) {
            <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        }
        <span class="pl-c">// Use the interface to call on the bank contract.</span>
        bool success <span class="pl-k">=</span> Bank(bank).withdraw(msg.sender, amount);

        <span class="pl-c">// If the transaction succeeded, pass the Ether on to the caller.</span>
        <span class="pl-k">if</span> (success) {
            msg.sender.<span class="pl-s3">send</span>(amount);
        }
        <span class="pl-k">return</span> success; 
    }

}
</pre>
</div> 
<p>Banking can now be made from the fund manager. It is possible to pass transactions to the fund-manager instead of the bank contract. This is good, because it adds separation of concerns, and it lets us add extra security checks and other things in the fund manager contract that are done before the actual bank contract is called (at least when we have made sure the bank functionality can only be accessed by the fund manager, which we'll do later). The system is not very modular, however, because we're stuck with this particular bank contract. What if we want to update the bank contract itself? </p> 
<p>What we should be doing here is work with an interface instead and allow the bank account to be swapped out:</p> 
<div class="highlight highlight-javascript">
 <pre>contract FundManager {

    address owner;
    <span class="pl-c">// This holds a reference to the current bank contract.</span>
    address bank;

    <span class="pl-c">// Constructor</span>
    <span class="pl-st">function</span> <span class="pl-en">FundManager</span>(){
        owner <span class="pl-k">=</span> msg.sender;
        <span class="pl-c">// We still start with the normal bank.</span>
        bank <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Bank</span>();
    }

    <span class="pl-c">// NEW</span>
    <span class="pl-c">// ********************************************************************************</span>

    <span class="pl-c">// Add a new bank address to the contract.</span>
    <span class="pl-st">function</span> <span class="pl-en">setBank</span>(<span class="pl-vpf">address</span> newBank) constant returns (bool res) {
        <span class="pl-k">if</span> (msg.sender <span class="pl-k">!=</span> owner){
            <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        }
        bank <span class="pl-k">=</span> newBank;
        <span class="pl-k">return</span> <span class="pl-c1">true</span>;
    }

    <span class="pl-c">// ********************************************************************************</span>

    <span class="pl-c">// Attempt to withdraw the given 'amount' of Ether from the account.</span>
    <span class="pl-st">function</span> <span class="pl-en">deposit</span>() constant returns (bool res) {
        <span class="pl-k">if</span> (msg.<span class="pl-sc">value</span> <span class="pl-k">==</span> <span class="pl-c1">0</span>){
            <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        }
        <span class="pl-k">if</span> ( bank <span class="pl-k">==</span> <span class="pl-c1">0x0</span> ) {
            <span class="pl-c">// If the user sent money, we should return it if we can't deposit.</span>
            msg.sender.<span class="pl-s3">send</span>(msg.<span class="pl-sc">value</span>);
            <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        }

        <span class="pl-c">// Use the interface to call on the bank contract. We pass msg.value along as well.</span>
        bool success <span class="pl-k">=</span> Bank(bank).deposit.<span class="pl-sc">value</span>(msg.<span class="pl-sc">value</span>)(msg.sender);

        <span class="pl-c">// If the transaction failed, return the Ether to the caller.</span>
        <span class="pl-k">if</span> (<span class="pl-k">!</span>success) {
            msg.sender.<span class="pl-s3">send</span>(msg.<span class="pl-sc">value</span>);
        }
        <span class="pl-k">return</span> success;
    }

    <span class="pl-c">// Attempt to withdraw the given 'amount' of Ether from the account.</span>
    <span class="pl-st">function</span> <span class="pl-en">withdraw</span>(<span class="pl-vpf">uint</span> amount) constant returns (bool res) {
        <span class="pl-k">if</span> ( bank <span class="pl-k">==</span> <span class="pl-c1">0x0</span> ) {
            <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        }
        <span class="pl-c">// Use the interface to call on the bank contract.</span>
        bool success <span class="pl-k">=</span> Bank(bank).withdraw(msg.sender, amount);

        <span class="pl-c">// If the transaction succeeded, pass the Ether on to the caller.</span>
        <span class="pl-k">if</span> (success) {
            msg.sender.<span class="pl-s3">send</span>(amount);
        }
        <span class="pl-k">return</span> success;
    }

}
</pre>
</div> 
<p>This system is better, but it is still not very flexible; nor is it safe. For one thing, we only allow the owner to set the bank. We might want a more sophisticated system for assigning permissions. We also need to protect the bank contract functions, of course, so they become accessible only from the fund manager.</p> 
<h4> <a id="user-content-more-permission-management" class="anchor" href="#more-permission-management" aria-hidden="true"><span class="octicon octicon-link"></span></a>More permission-management</h4> 
<p>First, let us add some simple user permission levels to the fund manager. We only use the value 0 for no permissions, and 1 for banking permissions at this point, but we use a <code>uint</code> instead of a <code>bool</code> so that we may extend it later. We will also make it possible to set the owner of the bank contract, so that we can set the owner address at any time instead of automatically assigning when the contract is deployed.</p> 
<div class="highlight highlight-javascript">
 <pre>contract Bank {

    address owner;

    mapping (address <span class="pl-k">=&gt;</span> uint) balances;

    <span class="pl-c">// Constructor</span>
    <span class="pl-st">function</span> <span class="pl-en">Bank</span>(){
    }

    <span class="pl-st">function</span> <span class="pl-en">setOwner</span>(<span class="pl-vpf">address</span> newOwner) constant returns (bool res) {
        <span class="pl-c">// IMPORTANT: We don't want to allow the user to be reassigned, except maybe by the</span>
        <span class="pl-c">// current owner.</span>
        <span class="pl-k">if</span> (owner <span class="pl-k">!=</span> <span class="pl-c1">0x0</span> <span class="pl-k">&amp;&amp;</span> msg.sender <span class="pl-k">!=</span> owner){
            <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        }
        owner <span class="pl-k">=</span> newOwner;
        <span class="pl-k">return</span> <span class="pl-c1">true</span>;
    }

    <span class="pl-c">// This will take the value of the transaction and add to the senders account.</span>
    <span class="pl-st">function</span> <span class="pl-en">deposit</span>(<span class="pl-vpf">address</span> customer) constant returns (bool res) {
        <span class="pl-k">if</span> (msg.sender <span class="pl-k">!=</span> owner){
            <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        }
        balances[customer] <span class="pl-k">+=</span> msg.<span class="pl-sc">value</span>;
        <span class="pl-k">return</span> <span class="pl-c1">true</span>;
    }

    <span class="pl-c">// Attempt to withdraw the given 'amount' of Ether from the account.</span>
    <span class="pl-st">function</span> <span class="pl-en">withdraw</span>(<span class="pl-vpf">address</span> customer, <span class="pl-vpf">uint</span> amount) constant returns (bool res) {
        <span class="pl-k">if</span> (msg.sender <span class="pl-k">!=</span> owner){
            <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        }
        <span class="pl-c">// Skip if someone tries to withdraw 0 or if they don't have enough Ether to make the withdrawal.</span>
        <span class="pl-k">if</span> (balances[customer] <span class="pl-k">&lt;</span> amount <span class="pl-k">||</span> amount <span class="pl-k">==</span> <span class="pl-c1">0</span>) 
            <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        balances[customer] <span class="pl-k">-=</span> amount;
        msg.sender.<span class="pl-s3">send</span>(amount);
        <span class="pl-k">return</span> <span class="pl-c1">true</span>;
    }

    <span class="pl-st">function</span> <span class="pl-en">remove</span>() {
        <span class="pl-k">if</span> (msg.sender <span class="pl-k">==</span> owner){
            suicide(owner);
        }
    }

}</pre>
</div> 
<div class="highlight highlight-javascript">
 <pre>contract FundManager {

    <span class="pl-c">// We still want an owner.</span>
    address owner;
    <span class="pl-c">// This holds a reference to the current bank contract.</span>
    address bank;

    <span class="pl-c">// Permissions</span>
    mapping (address <span class="pl-k">=&gt;</span> uint) perms;

    <span class="pl-c">// Constructor</span>
    <span class="pl-st">function</span> <span class="pl-en">FundManager</span>(){
        owner <span class="pl-k">=</span> msg.sender;
        bank <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Bank</span>();
        <span class="pl-c">// NEW</span>
        <span class="pl-c">// ********************************************************************************</span>
        Bank(bank).setOwner(address(<span class="pl-v">this</span>));
        <span class="pl-c">// ********************************************************************************</span>
    }

    <span class="pl-c">// Add a new bank address to the contract.</span>
    <span class="pl-st">function</span> <span class="pl-en">setBank</span>(<span class="pl-vpf">address</span> newBank) constant returns (bool res) {
        <span class="pl-k">if</span> (msg.sender <span class="pl-k">!=</span> owner){
            <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        }
        <span class="pl-c">// NEW</span>
        <span class="pl-c">// ********************************************************************************</span>
        bool result <span class="pl-k">=</span> Bank(newBank).setOwner(address(<span class="pl-v">this</span>));
        <span class="pl-c">// If we couldn't set ourself as owner, we will not add the bank.</span>
        <span class="pl-k">if</span>(<span class="pl-k">!</span>result){
            <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        }
        <span class="pl-c">// ********************************************************************************</span>
        bank <span class="pl-k">=</span> newBank;
        <span class="pl-k">return</span> <span class="pl-c1">true</span>;
    }

    <span class="pl-c">// NEW</span>
    <span class="pl-c">// ********************************************************************************</span>

    <span class="pl-c">// We're responsible for this now that we're the owner of the banks.</span>
    <span class="pl-st">function</span> <span class="pl-en">suicideBank</span>(<span class="pl-vpf">address</span> addr) {
        <span class="pl-k">if</span> (msg.sender <span class="pl-k">!=</span> owner){
            <span class="pl-k">return</span>;
        }
        Bank(addr).<span class="pl-s3">remove</span>();
    }

    <span class="pl-c">// Set the permissions for a user.</span>
    <span class="pl-st">function</span> <span class="pl-en">setPermission</span>(<span class="pl-vpf">address</span> user, <span class="pl-vpf">uint</span> perm) constant returns (bool res) {
        <span class="pl-k">if</span> (msg.sender <span class="pl-k">!=</span> owner){
            <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        }
        perms[user] <span class="pl-k">=</span> perm;
        <span class="pl-k">return</span> <span class="pl-c1">true</span>;
    }

    <span class="pl-c">// ********************************************************************************</span>

    <span class="pl-c">// Attempt to withdraw the given 'amount' of Ether from the account.</span>
    <span class="pl-st">function</span> <span class="pl-en">deposit</span>() constant returns (bool res) {
        <span class="pl-k">if</span> (msg.<span class="pl-sc">value</span> <span class="pl-k">==</span> <span class="pl-c1">0</span>){
            <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        }
        <span class="pl-k">if</span> ( bank <span class="pl-k">==</span> <span class="pl-c1">0x0</span> ) {
            <span class="pl-c">// If the user sent money, we should return it if we can't deposit.</span>
            msg.sender.<span class="pl-s3">send</span>(msg.<span class="pl-sc">value</span>);
            <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        }
        <span class="pl-c">// NEW</span>
        <span class="pl-c">// ********************************************************************************</span>
        <span class="pl-k">if</span>(perms[msg.sender] <span class="pl-k">!=</span> <span class="pl-c1">1</span>){
            <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        }
        <span class="pl-c">// ********************************************************************************</span>

        <span class="pl-c">// Use the interface to call on the bank contract. We pass msg.value along as well.</span>
        bool success <span class="pl-k">=</span> Bank(bank).deposit.<span class="pl-sc">value</span>(msg.<span class="pl-sc">value</span>)(msg.sender);

        <span class="pl-c">// If the transaction failed, return the Ether to the caller.</span>
        <span class="pl-k">if</span> (<span class="pl-k">!</span>success) {
            msg.sender.<span class="pl-s3">send</span>(msg.<span class="pl-sc">value</span>);
        }
        <span class="pl-k">return</span> success;
    }

    <span class="pl-c">// Attempt to withdraw the given 'amount' of Ether from the account.</span>
    <span class="pl-st">function</span> <span class="pl-en">withdraw</span>(<span class="pl-vpf">uint</span> amount) constant returns (bool res) {
        <span class="pl-k">if</span> ( bank <span class="pl-k">==</span> <span class="pl-c1">0x0</span> ) {
            <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        }

        <span class="pl-c">// NEW</span>
        <span class="pl-c">// ********************************************************************************</span>
        <span class="pl-k">if</span>(perms[msg.sender] <span class="pl-k">!=</span> <span class="pl-c1">1</span>){
            <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        }
        <span class="pl-c">// ********************************************************************************</span>

        <span class="pl-c">// Use the interface to call on the bank contract.</span>
        bool success <span class="pl-k">=</span> Bank(bank).withdraw(msg.sender, amount);

        <span class="pl-c">// If the transaction succeeded, pass the Ether on to the caller.</span>
        <span class="pl-k">if</span> (success) {
            msg.sender.<span class="pl-s3">send</span>(amount);
        }
        <span class="pl-k">return</span> success;
    }

}
</pre>
</div> 
<p>We now have a system that's similar to <code>HelloFactory</code> and <code>HelloSystem</code>. We can even make a basic dependency chart.</p> 
<p><a href="img/SSoSC1-2.png" target="_blank"><img src="img/SSoSC1-2.png" alt="SSoSC1-2" style="max-width:100%;" /></a></p> 
<p>There is more work to do, however. We have not enabled the system for handling multiple different bank types, which was the whole point to begin with. Also, we have not considered the implications of switching the bank account out. What of all the data that's still in there? We can't just cut it off and start a new bank, we would have to merge the old balances into the new contract somehow. Also, we would have to make sure we move the actual Ether stored in the old contract. Either that or make sure that the new bank gets permissions to operate on the old one, and does that as part of its functionality.</p> 
<p>What we've done here is a very common mistake: we did not separate the database from the controller. This is true in the bank contract but also in the fund manager; it keeps the permissions mapping in the same contract that operates on it. What if we want to update the permissions system? We'd have to replace the entire fund-manager contract.</p> 
<p>Also, the permissions structure is a bit more complicated now. Not only do we have the single-user permission to remove contracts and such, but we also have a second type of permission, which is to do banking. </p> 
<p>At this point we're gonna stop making patches though, and instead use a model in which some of the basics has been fleshed out.</p> 
<h3> <a id="user-content-systems-of-smart-contracts---the-five-types-model" class="anchor" href="#systems-of-smart-contracts---the-five-types-model" aria-hidden="true"><span class="octicon octicon-link"></span></a>Systems of smart contracts - the five types model</h3> 
<p>First of all: Every non-trivial DApp will require more then one contract to work well. There is no way to write a secure and scalable smart contract back-end without distributing the data and logic over multiple contracts. It may be hard to know exactly how to do this, so we're going to start by dividing contracts up into categories; instead of thinking about them in terms of what they do, we're going to start thinking about them in terms of what they are. There are many different ways to classify contracts, but we're going to use what I call &quot;the five types model&quot;. It is a simple model where contracts are divided up into five basic categories:</p> 
<p><strong>1) Database contracts</strong></p> 
<p>These are used only as data storage. The only logic they need is functions that allow other contracts to write, update and get data, and some simple way of checking caller permissions (whatever those permissions may be).</p> 
<p><strong>2) Controller contracts</strong></p> 
<p>These contracts operate on the storage contracts. In a flexible system, both controllers and databases can be replaced by other, similar contracts that share the same public api (although this is not always needed). Controllers can be advanced, and could for example do batched reads/writes, or read from and write to multiple different databases instead of just one.</p> 
<p><strong>3) Contract managing contracts (CMCs)</strong></p> 
<p>The purpose of these contracts is only to manage other contracts. Their main tasks is to keep track of all the contracts/components of the system, handle the communication between these components, and to make modular design easier. Keeping this functionality separate from normal business logic should be considered good practice, and has a number of positive effects on the system (as we will see later).</p> 
<p><strong>4) Application logic contracts (ALCs)</strong></p> 
<p>Application logic contracts contains application-specific code. Generally speaking, if the contract utilizes controllers and other contracts to perform application specific tasks it's an ALC.</p> 
<p><strong>5) Utility contracts</strong></p> 
<p>These type of contracts usually perform a specific task, and can be called by other contracts without restrictions. It could be a contract that hashes strings using some algorithm, provide random numbers, or other things. They normally don't need a lot of storage, and often have few or no dependencies.</p> 
<p>The rationale for this division will be laid out after we've tried to apply it to the fund manager system, as it will be a lot more clear then.</p> 
<h4> <a id="user-content-the-fund-management-system---take-2" class="anchor" href="#the-fund-management-system---take-2" aria-hidden="true"><span class="octicon octicon-link"></span></a>The fund management system - take 2</h4> 
<p>We will now analyze the fund management system using the five types model. It is a very small system so analyzing it will be simple. What we have is the bank component and the fund manager component. The functionality of the bank component is exposed only to the fund manager. The first thing we should be doing is to break the permissions part out of the fund manager, then we should divide the bank and permissions components up into controller and database contracts. This is what we'd get.</p> 
<p><a href="img/SSoSC1-3.png" target="_blank"><img src="img/SSoSC1-3.png" alt="SSoSC1-3" style="max-width:100%;" /></a></p> 
<p>Note how the permissions work. The bank does not use the permissions contract; it can still only be used by the <code>FundManager</code> contract. Permission checks will be done like before, except the code will be kept in a separate contract (or two, to be more exact). The two databases can only be accessed by their controllers, and the controllers only by the fund manager. The fund manager in turn does whatever the users tells it to do, ie it is not autonomous in any way. Same thing for the controllers.</p> 
<p>Also, this permissions chart is not complete. First of all, the owner could be a user as well and be allowed to do banking. Secondly, we actually have two types of permissions here, banking and administration (the adding and removal of contracts). If we wanted to do this right we would have to divide each contract account up into different sections, depending on the permissions needed to call the code in that block, and use one arrow for each permission type, but we're not going to that here. </p> 
<h4> <a id="user-content-adding-a-cmc" class="anchor" href="#adding-a-cmc" aria-hidden="true"><span class="octicon octicon-link"></span></a>Adding a CMC</h4> 
<p>Now we have to tie this all together. We need to make sure that the two controller-database pairs finds eachother, and that the fund manager finds the two controllers, but instead of keeping this type of logic in the contracts themselves we will break it out and put it into CMC contracts. If we wanted to do this right we would probably add one CMC for managing the controller-database flow for the bank, one for permissions and an additional one for the system as a whole, giving it a tree-like structure, but for simplicity we're going to flatten things and go with a standard CMC for everything:</p> 
<div class="highlight highlight-javascript">
 <pre><span class="pl-c">// The top level CMC</span>
contract Doug {

    address owner;

    <span class="pl-c">// This is where we keep all the contracts.</span>
    mapping (string32 <span class="pl-k">=&gt;</span> address) contracts;

    <span class="pl-st">function</span> <span class="pl-en">addContract</span>(<span class="pl-vpf">string32</span> name, <span class="pl-vpf">address</span> addr) {
        <span class="pl-k">if</span>(msg.sender <span class="pl-k">!=</span> owner){
            <span class="pl-k">return</span>;
        }
        contracts[name] <span class="pl-k">=</span> addr;
    }

    <span class="pl-st">function</span> <span class="pl-en">removeContract</span>(<span class="pl-vpf">string32</span> name) constant returns (bool result) {
        <span class="pl-k">if</span> (contracts[name] <span class="pl-k">==</span> <span class="pl-c1">0x0</span>){
            <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        }
        <span class="pl-k">if</span>(msg.sender <span class="pl-k">!=</span> owner){
            <span class="pl-k">return</span>;
        }
        contracts[name] <span class="pl-k">=</span> <span class="pl-c1">0x0</span>;
        <span class="pl-k">return</span> <span class="pl-c1">true</span>;
    }

    <span class="pl-st">function</span> <span class="pl-en">getContract</span>(<span class="pl-vpf">string32</span> name) returns (address addr) {
        <span class="pl-k">return</span> contracts[name];
    }

    <span class="pl-st">function</span> <span class="pl-en">remove</span>() {
        <span class="pl-k">if</span> (msg.sender <span class="pl-k">==</span> owner){
            suicide(owner);
        }
    }

}</pre>
</div> 
<p>Note that Doug is actually a misnomer. There is a type of Ethereum contracts called Dougs but they have a lot of components. One of the components is name registration, though, so I tend to call these type of top-level namereg CMCs Doug.</p> 
<p>We will use this contract to store the following contracts: &quot;fundmanager&quot;, &quot;bank&quot;, &quot;bankdb&quot;, &quot;perms&quot;, &quot;permsdb&quot;. We're also going to add links to Doug in all of them and then use it as glue. They'll call doug to get the address to contracts they need, cast them, and then call the functions. This is how it will work more specifically:</p> 
<p>All contracts that are part of this system will extend a <code>DougEnabled</code> contract, that will look like this:</p> 
<div class="highlight highlight-javascript">
 <pre><span class="pl-c">// Base class for contracts that are used in a doug system.</span>
contract DougEnabled {
    address DOUG;

    <span class="pl-st">function</span> <span class="pl-en">setDougAddress</span>(<span class="pl-vpf">address</span> dougAddr) returns (bool result){
        <span class="pl-c">// Once the doug address is set, don't allow it to be set again, except by the</span>
        <span class="pl-c">// doug contract itself.</span>
        <span class="pl-k">if</span>(DOUG <span class="pl-k">!=</span> <span class="pl-c1">0x0</span> <span class="pl-k">&amp;&amp;</span> dougAddr <span class="pl-k">!=</span> DOUG){
            <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        }
        DOUG <span class="pl-k">=</span> dougAddr;
        <span class="pl-k">return</span> <span class="pl-c1">true</span>;    
    }

}</pre>
</div> 
<p>This logic will be utilized by Doug when <code>addContract</code> is called, to set it. If the contract already has a Doug address, it will return false on <code>setDougAddress</code>, and in that case it will not be added.</p> 
<div class="highlight highlight-javascript">
 <pre><span class="pl-st">function</span> <span class="pl-en">addContract</span>(<span class="pl-vpf">string32</span> name, <span class="pl-vpf">address</span> addr) {
    <span class="pl-k">if</span>(msg.sender <span class="pl-k">!=</span> owner){
        <span class="pl-k">return</span>;
    }
    bool sda <span class="pl-k">=</span> DougEnabled(addr).setDougAddress(address(<span class="pl-v">this</span>));
    <span class="pl-k">if</span>(<span class="pl-k">!</span>sda){
        <span class="pl-k">return</span>;
    }
    contracts[name] <span class="pl-k">=</span> addr;
}</pre>
</div> 
<p>Databases will call doug when something tries to modify them. This would be how the bank does it:</p> 
<div class="highlight highlight-javascript">
 <pre><span class="pl-st">function</span> <span class="pl-en">deposit</span>(...) {
    ...

    address db <span class="pl-k">=</span> Doug(DOUG).getContract(<span class="pl-s1"><span class="pl-pds">&quot;</span>bankdb<span class="pl-pds">&quot;</span></span>);

    <span class="pl-k">if</span>(msg.sender <span class="pl-k">!=</span> db){
        <span class="pl-k">return</span>;
    }
    ...
}</pre>
</div> 
<p>Controllers would use Doug to check to make sure the caller is &quot;fundmanager&quot;, and it would also use Doug to get the address to the respecive database to do reads, and the fundmanager would use Doug to get the address to the bank and permission controllers. Also, again - using this CMC would be somewhat like craming everything into the global namespace. There is no real structure which is usually wrong but this is a small system and we want to keep things simple. In most systems you'd have more then one CMC and also more advanced CMC logic.</p> 
<h3> <a id="user-content-the-finished-system" class="anchor" href="#the-finished-system" aria-hidden="true"><span class="octicon octicon-link"></span></a>The finished system</h3> 
<p>The contracts and javascript can be found in the <code>resources</code>folder. I would suggest using the AlethZero client when working with the contracts. This is how this system would be deployed:</p> 
<p>1) Deploy Doug, keep track of its address.</p> 
<p>2) Deploy all the other contracts (doesn't matter in which order it's done), keep track of their addresses.</p> 
<p>3) Modify the doug address in <code>fundman.html</code>file. It's the line <code>var doug = web3.eth.contract(&quot;0x?????&quot;, DOUG_ABI)</code>. Don't forget the '0x' in front of the address. </p> 
<p>4) Load the html file in the aleth browser. </p> 
<p>5) Use 'Add To Doug' button to register the contracts under the following names (which is also their file names):</p> 
<ul> 
 <li>'doug' : doug</li> 
 <li>'permsdb' : the permissions database</li> 
 <li>'perms' : the permissions controller</li> 
 <li>'bankdb' : the bank database</li> 
 <li>'bank' : the bank controller</li> 
 <li>'fundmanager' : the fund manager</li> 
</ul> 
<p>This can be done by adding the name in the 'Name' field, then the address (with a 0x in front) in the 'Contract Address' field.</p> 
<p>6) Reload the browser window from the right-click menu.</p> 
<p>7) Set your own permission to 1.</p> 
<p>8) Start banking.</p> 
<p>Note: You can add other accounts as well, and add permissions to them etc.</p> 
<h3> <a id="user-content-extending-the-system" class="anchor" href="#extending-the-system" aria-hidden="true"><span class="octicon octicon-link"></span></a>Extending the system</h3> 
<p>If we want to add more banks to the system we could do that. The Doug contract makes it easy to add and remove contracts. We could also extend the already existing code quite easily - even when the system is running. Let's say we want to add logging to the bank. The idea is that a short log entry should be written when someone makes a deposit or withdrawal. The entry should contain the transaction type (deposit or withdraw), the amount of Ether, and the timestamp. How would we do that? </p> 
<p>In this system it would be simple. Trivial even. This is how we could do it:</p> 
<p>1) Keep fundmanager as is.</p> 
<p>2) Add the logging to a new bank controller. It would have the exact same code as the current one except it would also log.</p> 
<p>3) Register the new controller with Doug under the name &quot;bank&quot;</p> 
<p>4) Start using.</p> 
<p>We could actually add the log as a separate contract and register it with Doug, and use it that way. We could even give it a controller and database part like the other contracts, and maybe let the permissions manager and other components make use of it too.</p> 
<p>Another thing that could be done, which would improve the system a lot, is to link a lot of the owner stuff to permissions instead. What if we introduce 4 permission levels, where each level includes the permissions of all lower levels as well:</p> 
<p>0 means no permissions.</p> 
<p>1 means bank user permissions.</p> 
<p>2 means permissions to add bank permissions to others as well.</p> 
<p>3 highest permission level means being allowed to do anything, such as removing contracts, and also to give this permission to others.</p> 
<p>We could have the permissions contract automatically assign permission level 3 to the creator. This would be as easy as adding this constructor to the Permissions contract:</p> 
<div class="highlight highlight-javascript">
 <pre><span class="pl-st">function</span> <span class="pl-en">Permissions</span>() {
    perms[msg.sender] <span class="pl-k">=</span> <span class="pl-c1">4</span>;
}</pre>
</div> 
<p>What we'd do next is replace some of the checks for (msg.sender == owner) with permissions checks.</p> 
<p>Current setPermissions function in the fund manager.</p> 
<div class="highlight highlight-javascript">
 <pre><span class="pl-c">// Set the permissions for a given address.</span>
<span class="pl-st">function</span> <span class="pl-en">setPermission</span>(<span class="pl-vpf">address</span> addr, <span class="pl-vpf">uint8</span> permLvl) constant returns (bool res) {
    <span class="pl-k">if</span> (msg.<span class="pl-sc">caller</span> <span class="pl-k">!=</span> owner){
        <span class="pl-k">return</span> <span class="pl-c1">false</span>;
    }
    address perms <span class="pl-k">=</span> Doug(DOUG).getContract(<span class="pl-s1"><span class="pl-pds">&quot;</span>perms<span class="pl-pds">&quot;</span></span>);
    <span class="pl-k">if</span> ( perms <span class="pl-k">==</span> <span class="pl-c1">0x0</span> ) {
        <span class="pl-k">return</span> <span class="pl-c1">false</span>;
    }
    <span class="pl-k">return</span> Permissions(perms).setPermission(addr,permLvl);
}</pre>
</div> 
<p>New </p> 
<div class="highlight highlight-javascript">
 <pre><span class="pl-c">// Set the permissions for a given address.</span>
<span class="pl-st">function</span> <span class="pl-en">setPermission</span>(<span class="pl-vpf">address</span> addr, <span class="pl-vpf">uint8</span> permLvl) constant returns (bool res) {
    address perms <span class="pl-k">=</span> Doug(DOUG).getContract(<span class="pl-s1"><span class="pl-pds">&quot;</span>perms<span class="pl-pds">&quot;</span></span>);
    <span class="pl-k">if</span> ( perms <span class="pl-k">==</span> <span class="pl-c1">0x0</span> ) {
        <span class="pl-k">return</span> <span class="pl-c1">false</span>;
    }
    Permissions pc <span class="pl-k">=</span> Permissions(perms);
    uint8 userPerm <span class="pl-k">=</span> pc.getPermission(addr);
    <span class="pl-k">if</span>(userPerm <span class="pl-k">&lt;</span> <span class="pl-c1">3</span>) {
        <span class="pl-k">return</span> <span class="pl-c1">false</span>;
    }
    <span class="pl-k">return</span> pc.setPermission(addr, permLvl);
}</pre>
</div> 
<p>Also, as we talked about before, what if we want to add more types of banks? That is not hard. We could choose to do it in several ways. One way would be to add many databases and update the bank controller into one that handles multiple databases. We could just give the databases different names in DOUG and make sure the controller knows who they are. Another way of doing it would be to add more banks. There could be several &quot;full&quot; banks, with both controllers and databases. Doug has room for them all. </p> 
<p>The fundmanager would also have to be updated of course, but that is not a problem. With a system like this, it is very easy to make updates, but at the same time it is easy to fall into traps. If we were to add a bunch of contracts to this system, for example, we would run into problems because DOUG is not designed to get rid of them. Its remove function only kills the current ones. Even though it is an extendible system in theory, that does not mean all contracts automatically supports updates.</p> 
<h3> <a id="user-content-cost-benefit-analysis" class="anchor" href="#cost-benefit-analysis" aria-hidden="true"><span class="octicon octicon-link"></span></a>Cost benefit analysis</h3> 
<p>Given all of the extra contracts and indirection that's needed, we may ask if it's even worth doing. For example, if all I want to do is to deposit some money, why do i have to call one contract that calls a second contract that calls a third one, also doing calls to a fourth one all the way? </p> 
<p>There are some things to consider when deciding how the system should be designed. Modularity is good, but it comes with a price. All this indirection means more calls and more processing, which means the cost for executing the code is higher, and the added bytecode makes the system more bulky. Maybe the system needs to be extremely flexible. Maybe a highly extendible system can be built as a test, using a model like this, but when the system and its components are getting stable and it's clear what it should be doing, then switch to a simpler one. It all depends. </p> 
<p>There is also the matter of trust, but I treat that in the beginning of the document.</p> 
<h3> <a id="user-content-coming-next" class="anchor" href="#coming-next" aria-hidden="true"><span class="octicon octicon-link"></span></a>Coming next</h3> 
<p>This is the plan as it stands now.</p> 
<p>In part 2 we will look at an architecture that is more general then the one we created here. I call it an &quot;action driven architecture&quot;, and it is based on the architecture I used for &quot;The People's Republic of Doug&quot;. This will be published fairly soon, as most of it is already written.</p> 
<p>Part 3 will contain an analysis of the example system using the five types model. This is a small part, and has also largely been written.</p> 
<p>Part 4 will contain some more in-depth material on systems, and a few techniques for circumventing bad setups after the contracts has already been put in place.</p> 
<p>Part 5 will be about working with smart contract systems that drive regular web applications. We will look at a normal web application using a RESTful API, and see how we can mold the smart contract back-end to fit the system as a whole.</p> 
<p>In part 6 we will put together a small toolkit for designing smart contract systems. There will be some basic utility contracts written in Solidity, a few cheet-sheats, a more evolved model then &quot;the five types&quot; for analysis, and also a better system for doing permissions/dependency mapping.</p> 
<p>These documents, in addition to any more parts that might be added, will be used as the basis of a proper book on this subject.</p>
</body>
</html>
